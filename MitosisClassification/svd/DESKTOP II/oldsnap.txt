#include "includes.h"
#include "stdafx.h"
#include <math.h>
#include "interpolation.h"
#include "ap.h"
#include "spline.h"
#include <numeric>


using namespace cv;
using namespace std;
//using namespace alglib_impl;
using namespace alglib;
using namespace tk;

#ifndef HELPERS_H
#define	HELPERS_H

double distance(double x1, double y1, double x2, double y2) {
	return sqrt(pow((x2-x1), 2) + pow((y2-y1), 2));
}

template <typename T>
std::string to_string_with_precision(const T a_value, const int n = 6)
{
    std::ostringstream out;
    out << std::setprecision(n) << a_value;
    return out.str();
}

Mat extractContour(Mat image, vector<Event> d1, vector<Event> d2) {
		Mat contour = Mat::zeros(image.size(), CV_8UC3);

		Mat tofill = image.clone();
		GaussianBlur(tofill, tofill, Size(5, 5), 3);
		medianBlur(tofill, tofill, 31);
		Mat mask(image.rows + 2, image.cols + 2, CV_8UC1, Scalar(0,0,0));
		cout<< image.rows<<" "<<image.cols<<endl<<endl;
		// Choose a black corner;
		int offset = 20;
		Point corners[] = {Point(offset, offset), Point(image.cols - 1 - offset, offset),
			Point(image.cols - 1 - offset, image.rows - 1 - offset), Point(offset, image.rows - 1 - offset)};

		int crn = 0;

		for (int i = 0; i < 4; i++) {
			if ((int)tofill.at<uchar>(corners[i].y, corners[i].x) == 0) {
				cout<<"Corner "<<i<<" "<<(int)tofill.at<uchar>(corners[i].y, corners[i].x)<<endl;
				crn = i; break;
			}
			circle(contour, corners[i], 3, Scalar(255, 255, 255), -1, 8);
			putText(contour, to_string((int)tofill.at<uchar>(corners[i].y, corners[i].x)),corners[i] + Point(-5, -8),FONT_HERSHEY_COMPLEX_SMALL, .8, cvScalar(255, 255, 255), 1, false);			
		}


		floodFill(tofill, mask, corners[crn], Scalar(255, 255, 255),
			0, Scalar(), Scalar(), 4);

		vector<Mat> contours;
		findContours(mask, contours, RETR_EXTERNAL, CHAIN_APPROX_TC89_L1);
		//cout<<contours[0].type()<<endl;
		vector<Mat> points;
		split(contours[0], points);
		vector<int> x; vector<int> y;
		points[0].reshape(1, 1).row(0).copyTo(x); points[1].reshape(1, 1).row(0).copyTo(y);
		vector<Point> curve;
		for (int i = 0; i < x.size(); i++) curve.push_back(Point(x[i], y[i]));
		int begin = -1; int end = -1;
		for (int i = 0; i < contours[0].rows - 1; i++) {
			//int x = points[0].at<int>(i,0); int y = points[1].at<int>(i,0);
			//cout<<x[i]<<" "<<y[i]<<endl;
			//if (begin == -1 && distance(x[i], y[i], x[i+1], y[i+1]) < 10) {
			if (begin == -1 && x[i]>1 && y[i]>1 && x[i] < image.cols && y[i] < image.rows) {
				begin = i;
				cout<<"BEGIN: "<<begin<<endl;
			}

			//if (end == -1 && begin != -1 && distance(x[i], y[i], x[i+1], y[i+1]) > 10) {
			if (end == -1 && begin != -1 && (x[i+1]<=1 || y[i+1]<=1 || x[i] >= image.cols || y[i] >= image.rows)) {
				end = i;
				cout<<"END: "<<end<<endl;
			}
			/*
			if (begin != -1 && (i - begin)%50 == 0) {
				circle(contour, Point(x[i],y[i]), 3, Scalar(255, 255, 255), -1, 8);
				putText(contour, to_string(i - begin),Point(x[i] + 5, y[i] + 8),FONT_HERSHEY_COMPLEX_SMALL, .8, cvScalar(255, 255, 255), 1, false);	
			}
			*/
		}
		/*
		circle(contour, Point(x[end],y[end]), 3, Scalar(255, 255, 255), -1, 8);
		putText(contour, "END",Point(x[end] + 5, y[end] + 8),FONT_HERSHEY_COMPLEX_SMALL, .8, cvScalar(255, 255, 255), 1, false);
		*/
		if (begin!=-1 && end!=-1) {
			int npoints = 30;
			int interval = (end - begin + 1)/npoints;
			vector<double> ix; vector<double> iy;
			vector<int> breakpoints;
			bool increasing = x[begin] < x[begin+1];
			for (int i = begin; i<=end; i+=interval) {
				if (i!=begin) {
					if(increasing && x[i] >= x[i+1]) {
						breakpoints.push_back(i+1);
					}
					if(!increasing && x[i] >= x[i+1]) {
						breakpoints.push_back(i+1);
					}
				}
				ix.push_back(x[i]); iy.push_back(y[i]);
				circle(contour, Point(x[i],y[i]), 3, Scalar(255, 255, 255), -1, 8);
				putText(contour, to_string((i - begin)/interval),Point(x[i] + 5, y[i] + 8),FONT_HERSHEY_COMPLEX_SMALL, .8, cvScalar(255, 255, 255), 1, false);			
			}
			spline sx, sy;
			vector<double> t(ix.size());
			iota(t.begin(), t.end(), 1);
			sx.set_points(t, ix);
			sy.set_points(t, iy);
			for (float i = 0; i < ix.size(); i+=0.01) {
				circle(contour, Point(sx(i), sy(i)), 0.5, Scalar(255, 255, 255), -1, 8);
			}
			for (int point = 0; point < npoints; point +=3) {
				double m = sy.derivative(t[point])/sx.derivative(t[point]);
				double new_x = ix[point]+100;
				double b = (iy[point] - m*ix[point]);
				double new_y = new_x*m + b;
				line(contour, Point(ix[point]-100, (ix[point]-100)*m + b), Point(new_x, new_y), Scalar(255, 0, 0));
			}
			/*
			s.set_points(ix, iy);
			for (int i = 0; i < ix.size() - 1; i++) {
				float p = ix[i];
				int sign = ix[i+1] - ix[i] >= 0? 1 : -1;
				while((ix[i+1] - p)*sign >= 0) {
					p += sign*0.1;
					circle(contour, Point(p, s.interp(p, i)), 0.5, Scalar(255, 255, 255), -1, 8);
					
				}
			} 
			*/

		} else {
			cout<<"Begin or end were not found.\n";
		}
		/*
		alglib::spline1dinterpolant s;
		ae_int_t natural_bound_type = 2;
		//
		// Test exact boundary conditions: build S(x), calculare S(0.25)
		// (almost same as original function)
		//
		alglib::real_1d_array a;
		a.setcontent(6, &ix[0]);
		alglib::real_1d_array b;
		b.setcontent(6, &iy[0]);
		for (int i=0;i<6;i++) {
			cout<<a[i]<<" "<<b[i]<<endl;
		}
		spline1dbuildcubic(a, b, s);
		
		for (float i = ix[0]; i < ix[10]; i+=0.01) {
			double new_point = spline1dcalc(s, i);
			circle(contour, Point(i,new_point), 0.5, Scalar(0, 0, 255), -1, 8);
		}
		
		//v = spline1dcalc(s, t);
		//printf("%.4f\n", double(v)); // EXPECTED: 0.0625		

		*/


		/*
		drawContours(contour, contours, -1, Scalar(255, 255, 255));

		struct X { // 
			Point c;
			X(Point a): c(a) {};
			public:
				float angle(Point p1, Point p3) {
					float x1 = p1.x - c.x; float y1 = p1.y - c.y;
					float x2 = p3.x - c.x; float y2 = p3.y - c.y;
					float dot = x1*x2 + y1*y2;	// dot product
					float det = x1*y2 - y1*x2;	// determinant
					return 180 / 3.14159265 * atan2(det, dot);	// atan2(y, x) or atan2(sin, cos)
				}
				bool operator () (Point a, Point b) {
					return norm(a - c) > norm(b - c);
				}
		};

		for (int i = 0; i < d1.size() && i < d2.size(); i++) {
			Point3f p1 = d1[i].getCoordinates(); Point3f p2 = d2[i].getCoordinates();
			Point daught1 = Point(p1.x, p1.y); Point daught2 = Point(p2.x, p2.y);
			line(contour, Point(p1.x, p1.y), Point(p2.x, p2.y), Scalar(255, 0, 0), 2);
			Point3f center = (p1 + p2)/2.0;
			//int maxa = max_element(curve.begin(), curve.end(), X(Point(p1.x, p1.y))) - curve.begin();
			Point a = *max_element(curve.begin(), curve.end(), X(Point(p1.x, p1.y)));
			Point b = *max_element(curve.begin(), curve.end(), X(Point(center.x, center.y)));
			Point c = *max_element(curve.begin(), curve.end(), X(Point(p2.x, p2.y)));
			line(contour, a, c, Scalar(0, 255, 0), 2);
			circle(contour, a, 3, Scalar(0, 255, 255), -1, 8);
			circle(contour, b, 3, Scalar(255, 0, 0), -1, 8);
			circle(contour, c, 3, Scalar(0, 0, 255), -1, 8);

			float angle = abs(X(c).angle(a, daught1 - daught2 + c));
			putText(contour, to_string_with_precision(angle, 4), c + Point(10, 10),FONT_HERSHEY_COMPLEX_SMALL, 1, cvScalar(255, 255, 255), 1, false);
		}

		*/
		return contour;
}

#endif